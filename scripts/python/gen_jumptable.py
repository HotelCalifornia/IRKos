#!/usr/bin/env python3
import os.path
import textwrap
from typing import Union, List, NamedTuple, Dict

import yaml

with open('../jumptable.yaml', 'r') as jumptable:
    jumptable_raw = yaml.safe_load(jumptable)

print(jumptable_raw)


class Function(NamedTuple):
    return_type: str
    name: str
    args: List[Union[Dict]]

    @classmethod
    def decl_args(cls, args):
        args_ = []
        for a in args:
            if a.get('type') == 'function':
                # need to recurse down into function pointer arguments
                args_.append(f"{a.get('return')} (*{a.get('name')})({', '.join(Function.decl_args(a.get('args')))})")
            else:
                args_.append(f"{a.get('type')} {a.get('name')}")

        return args_


class Declaration(Function):
    def __new__(cls, *args, **kwargs):
        return super(Declaration, cls).__new__(cls, *args, **kwargs)

    def __str__(self):
        return f"{self.return_type} {self.name}({', '.join(Function.decl_args(self.args))});"


class Definition(Function):
    def __new__(cls, index: int, *args):
        self = super(Definition, cls).__new__(cls, *args)
        self.index = index
        return self

    def __str__(self):
        args = ', '.join(Function.decl_args(self.args))
        return textwrap.dedent(f"""
            {self.return_type} {self.name}({args}) {{
                {self.return_type} (*func)({args}) = 
                    *(({self.return_type} (**const)({args}))PTR_ADDR({self.index}));
                
                return func({', '.join([a.get('name') for a in self.args])});
            }}""")


header_comment = textwrap.dedent(f"""\
/** File generated by {os.path.basename(__file__)}, do not modify! **/

""")

header_include = textwrap.dedent(f"""\
#include <stdint.h>

""")

with open('../linker/irk_jumptable.ld', 'w+') as ld_script:
    ld_script.write(header_comment)
    ld_script.write(
        textwrap.dedent(f"""\
        __JUMPTABLE_BASE = {hex(jumptable_raw.get('base'))};
        """)
    )


with open('../include/jumptable/irk_jumptable_api.h', 'w+') as api_header, \
        open('../include/jumptable/irk_jumptable_boot.h', 'w+') as boot_header:
    contents = header_comment + \
        header_include + \
        ';\n'.join(
            [f"{Declaration(f.get('return'), f.get('name'), f.get('args'))}" for f in jumptable_raw.get('functions')]
        )

    api_header.write(contents)
    boot_header.write(contents)

with open('../src/jumptable/irk_jumptable_api.c', 'w+') as api_implementation:
    api_implementation.write(header_comment)
    api_implementation.write(header_include)
    api_implementation.write(
        textwrap.dedent(
            f"""
            #define PTR_ADDR(index) ({hex(jumptable_raw.get('base'))} + (index * sizeof(void (*const)(void))))
            """
        )
    )
    fns = jumptable_raw.get('functions')
    api_implementation.write(
        '\n'.join(
            [f"{Definition(i, f.get('return'), f.get('name'), f.get('args'))}" for i, f in zip(range(len(fns)), fns)]
        )
    )

with open('../src/jumptable/irk_jumptable_boot.c', 'w+') as boot_implementation:
    boot_implementation.write(header_comment)
    boot_implementation.write(header_include)
    table_entries = ',\n'.join([f"(void (*const)(void))&{f.get('name')}" for f in jumptable_raw.get('functions')])
    boot_implementation.write(textwrap.dedent(f"""
        #include "jumptable/irk_jumptable_boot.h"
        #define PTR_ADDR(index) ({hex(jumptable_raw.get('base'))} + (index * sizeof(void (*const)(void)))
    
        void (*const jumptable[])(void) __attribute__((section(".jumptable"))) = {{
               {table_entries}
        }};
    """))
